/* =============================================================
   BLOCK: GLOBAL VARIABLES & CONFIG BEGIN
   ============================================================= */
/*
    Collar Chat Plugin (Strict LSL, 2025-07-07c)
    - Handles chat commands, options menu, and dynamic module learning.
    - Compatible with GUH plugin framework.
*/

integer DEBUG = TRUE;
float   dialog_timeout     = 180.0;

/* Persistent chat settings */
string  g_prefix           = "";      // Command prefix (2–5 chars)
integer g_public_listener  = FALSE;   // Whether to watch public chat

/* Dynamic module registry from 500-register plugin messages */
list    g_modules          = [];      // Holds ctx names of known modules

/* Session cache: [av, page, csv, expiry, ctx, param, step, menucsv, chan, listen] */
list    g_sessions;
/* =============================================================
   BLOCK: GLOBAL VARIABLES & CONFIG END
   ============================================================= */


/* =============================================================
   BLOCK: SESSION HELPERS BEGIN
   ============================================================= */
/*
    Session management helpers: consistent with core/access/animate plugins.
*/

integer s_idx(key av) { return llListFindList(g_sessions, [av]); }

integer s_set(key av, integer page, string csv, float expiry,
              string ctx, string param, string step, string menucsv, integer chan)
{
    integer i = s_idx(av);
    if (i != -1) {
        integer old = llList2Integer(g_sessions, i+9);
        if (old != -1) llListenRemove(old);
        g_sessions = llDeleteSubList(g_sessions, i, i+9);
    }
    integer lh = llListen(chan, "", av, "");
    g_sessions += [av, page, csv, expiry, ctx, param, step, menucsv, chan, lh];
    return TRUE;
}
integer s_clear(key av) {
    integer i = s_idx(av);
    if (i != -1) {
        integer old = llList2Integer(g_sessions, i+9);
        if (old != -1) llListenRemove(old);
        g_sessions = llDeleteSubList(g_sessions, i, i+9);
    }
    return TRUE;
}
list s_get(key av) {
    integer i = s_idx(av);
    if (i != -1) return llList2List(g_sessions, i, i+9);
    return [];
}
/* =============================================================
   BLOCK: SESSION HELPERS END
   ============================================================= */


/* =============================================================
   BLOCK: MENU DEFINITIONS BEGIN
   ============================================================= */
/*
    Core menu buttons and context identifiers for dialog menus.
*/

list core_menu_buttons() { return ["Change Prefix", "Toggle Public"]; }
list core_menu_ctxs()    { return ["enter_prefix",   "toggle_public"]; }

show_chat_menu(key av, integer chan) {
    list btns = core_menu_buttons();
    while (llGetListLength(btns) % 3 != 0) btns += " ";
    s_set(av, 0, " ",
          llGetUnixTime() + dialog_timeout,
          "chat_main", "", "",
          llDumpList2String(core_menu_ctxs(), ","), chan);
    llDialog(av, "Chat Plugin Options:", btns, chan);
}
/* =============================================================
   BLOCK: MENU DEFINITIONS END
   ============================================================= */


/* =============================================================
   BLOCK: TIMEOUT MANAGEMENT BEGIN
   ============================================================= */
/*
    Dialog timeout and session expiry logic.
*/

timeout_check() {
    integer now = llGetUnixTime();
    integer i = 0;
    while (i < llGetListLength(g_sessions)) {
        float expiry = llList2Float(g_sessions, i+3);
        key av       = llList2Key(g_sessions, i);
        if (now > expiry) {
            llInstantMessage(av, "Chat menu timed out.");
            s_clear(av);
        } else {
            i += 10;
        }
    }
}
/* =============================================================
   BLOCK: TIMEOUT MANAGEMENT END
   ============================================================= */


/* =============================================================
   BLOCK: MAIN EVENT LOOP BEGIN
   ============================================================= */
/*
    Main state and event handling for Chat plugin:
    - state_entry:     GUH plugin registration, sets timer.
    - link_message:    Learns new module ctx from register, opens menu on GUH 510.
    - listen:          Handles dialog session logic and public chat command relay.
    - timer:           Calls timeout_check.
*/

default
{
    state_entry()
    {
        if (DEBUG) llOwnerSay("[Chat] state_entry");
        llSetTimerEvent(1.0);
        // Register Chat with GUH
        llMessageLinked(LINK_THIS, 500, "register|1003|Chat|3|chat", NULL_KEY);
    }

    link_message(integer sender, integer num, string str, key id)
    {
        if (num == 500)
        {
            // Plugin registration from other modules: learn ctx
            list p = llParseStringKeepNulls(str, ["|"], []);
            // p = ["register", "<sn>", "<label>", "<min_acl>", "<ctx>"]
            if (llGetListLength(p) >= 5 && llList2String(p, 0) == "register")
            {
                string ctx = llList2String(p, 4);
                if (llListFindList(g_modules, [ctx]) == -1)
                {
                    g_modules += [ctx];
                    if (DEBUG) llOwnerSay("[Chat] learned module: " + ctx);
                }
            }
            return;
        }
        // GUH → Chat: 510 open menu
        if (num == 510)
        {
            list a = llParseString2List(str, ["|"], []);
            if (llGetListLength(a) >= 3 && llList2String(a, 0) == "chat")
            {
                key av   = (key) llList2String(a, 1);
                integer chan = (integer) llList2String(a, 2);
                if (DEBUG) llOwnerSay("[Chat] opening menu for " + (string)av);
                show_chat_menu(av, chan);
            }
        }
    }

    listen(integer chan, string name, key id, string msg)
    {
        /* 
            Dialog/menu logic would go here, using s_get(), s_set(), and s_clear().
            You can add more dialog code as needed, e.g., to set prefix or toggle public.
        */

        // Public chat command handler
        if (g_public_listener && (chan == 0 || chan == 1))
        {
            if (g_prefix == "") return;
            list tokens = llParseString2List(msg, [" "], []);
            if (llGetListLength(tokens) < 2) return;

            string pfx    = llToLower(llList2String(tokens, 0));
            string module = llToLower(llList2String(tokens, 1));
            if (pfx != llToLower(g_prefix)) return;

            // Dynamic module allow-list check:
            if (llListFindList(g_modules, [module]) == -1)
            {
                if (DEBUG) llOwnerSay("[Chat] UNKNOWN module → " + module);
                return;
            }

            // Forward to GUH (510)
            integer argc = llGetListLength(tokens) - 2;
            string out = module + "|" + (string)id + "|" + (string)chan;
            integer i;
            for (i = 0; i < argc; ++i)
            {
                out += "|" + llList2String(tokens, 2 + i);
            }
            llMessageLinked(LINK_THIS, 510, out, NULL_KEY);
            if (DEBUG) llOwnerSay("[Chat] cmd→ " + out);
        }
    }

    timer() {
        timeout_check();
    }
}
/* =============================================================
   BLOCK: MAIN EVENT LOOP END
   ============================================================= */
