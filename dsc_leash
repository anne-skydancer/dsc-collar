// =============================================================
//  D/s Collar Leash Plugin – strict LSL, GUH conventions, leash mechanics
//  Version: 2025-07-06  (menu, dialog, leash follow, particles, controls)
// =============================================================

integer debug = TRUE;

/*──────── persistent state ────────*/
integer g_leashed        = FALSE;
key     g_leasher        = NULL_KEY;
integer g_leash_length   = 2;     // 1–20 meters, default 2
integer g_follow_mode    = FALSE;
integer g_controls_ok    = FALSE;
integer g_turn_to        = FALSE;
vector  g_anchor         = ZERO_VECTOR;
string  g_chain_texture  = "5c472de3-ac7e-d7d3-f26f-8c8f35987fd7"; // example chain

/*──────── session helpers ────────*/
list    g_sessions;

integer sidx(key av){ return llListFindList(g_sessions,[av]); }
integer sset(key av,integer page,string csv,float exp,string ctx,string param,string step,string mcsv,integer chan)
{
    integer i = sidx(av);
    if(~i){
        integer old = llList2Integer(g_sessions,i+9);
        if(old!=-1) llListenRemove(old);
        g_sessions = llDeleteSubList(g_sessions,i,i+9);
    }
    integer lh = llListen(chan,"",av,"");
    g_sessions += [av,page,csv,exp,ctx,param,step,mcsv,chan,lh];
    return TRUE;
}
integer sclear(key av){
    integer i = sidx(av);
    if(~i){
        integer old = llList2Integer(g_sessions,i+9);
        if(old!=-1) llListenRemove(old);
        g_sessions = llDeleteSubList(g_sessions,i,i+9);
    }
    return TRUE;
}
list sget(key av){
    integer i = sidx(av);
    if(~i) return llList2List(g_sessions,i,i+9);
    return [];
}

/*──────── menu buttons ────────*/
list leash_menu_btns(integer acl)
{
    return ["Leash", "Unleash", "Set Length", "Follow", "Turn", "Unclip"];
}

/*──────── leash anchor ────────*/
vector leash_anchor_point()
{
    integer nprims = llGetNumberOfPrims();
    integer i;
    for(i=2;i<=nprims;++i)
    {
        string nm = llGetLinkName(i);
        string desc = llList2String(llGetLinkPrimitiveParams(i,[PRIM_DESC]),0);
        if(llToLower(nm) == "leashring" || llToLower(desc) == "leash:ring")
        {
            vector child_local = llList2Vector(llGetLinkPrimitiveParams(i, [PRIM_POS_LOCAL]), 0);
            vector root_pos = llGetRootPosition();
            rotation root_rot = llGetRootRotation();
            return root_pos + (child_local * root_rot);
        }
    }
    return llGetRootPosition();
}

/*──────── main menu ────────*/
show_leash_menu(key av,integer chan){
    integer acl = 4; // placeholder for public, can wire to GUH getacl if needed
    list btns = leash_menu_btns(acl);
    while(llGetListLength(btns)%3!=0) btns += [" "];
    sset(av,0,"",llGetUnixTime()+180.0,"menu","","","",chan);

    string st = "Leash state:\n";
    if(g_leashed) st += "Leashed to: "+llKey2Name(g_leasher)+"\n";
    else st += "Not leashed\n";
    st += "Length: "+(string)g_leash_length+" m";
    if(g_turn_to) st += "\nTurn: ON";
    else st += "\nTurn: OFF";
    llDialog(av,st,btns,chan);
}

/*──────── leash length dialog (vertical) ────────*/
show_leash_length_menu(key av, integer chan)
{
    // "Back","OK","Cancel" on nav row (top), numbers go DOWN below nav row
    list buttons = ["Back", "OK", "Cancel", "10", "15", "20", "1", "2", "5"];
    sset(av, 0, "", llGetUnixTime() + 180.0, "set_length", "", "", "", chan);
    string info = "Select leash length (meters):\nCurrent: " + (string)g_leash_length + " m";
    llDialog(av, info, buttons, chan);
}

/*──────── leash visual particles ────────*/
draw_leash_particles(key to)
{
    vector start = leash_anchor_point();
    vector target = llGetRootPosition();
    if(to != NULL_KEY && to != llGetOwner())
    {
        list det = llGetObjectDetails(to, [OBJECT_POS]);
        if(llGetListLength(det)>0) target = llList2Vector(det, 0);
    }
    list psys = [
        PSYS_SRC_PATTERN, PSYS_SRC_PATTERN_DROP,
        PSYS_SRC_TEXTURE, g_chain_texture,
        PSYS_SRC_BURST_RATE, 0.02,
        PSYS_SRC_BURST_PART_COUNT, 1,
        PSYS_PART_START_SCALE, <0.06,0.06,0>,
        PSYS_PART_END_SCALE, <0.06,0.06,0>,
        PSYS_PART_MAX_AGE, 1.2,
        PSYS_PART_FLAGS, PSYS_PART_INTERP_COLOR_MASK | PSYS_PART_FOLLOW_SRC_MASK | PSYS_PART_TARGET_POS_MASK,
        PSYS_SRC_TARGET_KEY, to,
        PSYS_PART_START_COLOR, <1,1,1>,
        PSYS_PART_END_COLOR, <1,1,1>
    ];
    llParticleSystem(psys);
}

stop_leash_particles()
{
    llParticleSystem([]);
}

/*──────── timeout check ────────*/
timeout_check(){
    integer now = llGetUnixTime();
    integer i=0;
    while(i<llGetListLength(g_sessions)){
        if(now>llList2Float(g_sessions,i+3))
             sclear(llList2Key(g_sessions,i));
        else i += 10;
    }
}

/*──────── leash logic: keep wearer in leash range ────────*/
leash_follow_logic()
{
    if(!g_leashed || g_leasher == NULL_KEY) return;

    key wearer = llGetOwner();
    key leasher = g_leasher;
    vector wearer_pos = llGetRootPosition();
    vector anchor = leash_anchor_point();
    vector leash_point = anchor;

    if(leasher != wearer)
    {
        list det = llGetObjectDetails(leasher,[OBJECT_POS]);
        if(llGetListLength(det)>0)
            leash_point = llList2Vector(det,0);
    }

    float max_len = (float)g_leash_length;
    vector offset = wearer_pos - leash_point;
    float dist = llVecMag(offset);

    if(dist > max_len)
    {
        // leash vector enforcement
        if(g_controls_ok)
        {
            vector tgt = leash_point + llVecNorm(offset) * max_len * 0.98;
            llMoveToTarget(tgt, 0.5);
            if(g_turn_to)
            {
                vector v = leash_point - wearer_pos;
                float angle = llAtan2(v.x, v.y);
                // Needs RLV for forced rotation in real use
                // Here, could only face or send a debug
            }
        }
        // Optionally, RLV tether restriction goes here
    }
    draw_leash_particles(leasher);
}

/*──────── default state ────────*/
default
{
    state_entry(){
        if(debug) llOwnerSay("[leash] Ready.");
        llMessageLinked(LINK_THIS,500,"register|1003|leash|4|leash",NULL_KEY);
        llRequestPermissions(llGetOwner(), PERMISSION_TAKE_CONTROLS);
        llSetTimerEvent(0.4);
    }

    run_time_permissions(integer perm)
    {
        if(perm & PERMISSION_TAKE_CONTROLS) g_controls_ok = TRUE;
        else g_controls_ok = FALSE;
    }

    link_message(integer sn,integer num,string str,key id)
    {
        if(num == 510)
        {
            // "leash|<avatar>|<chan>"
            list a = llParseString2List(str, ["|"], []);
            if(llList2String(a,0) == "leash" && llGetListLength(a) >= 3)
            {
                key av   = (key)llList2String(a, 1);
                integer chan = (integer)llList2String(a, 2);
                show_leash_menu(av, chan);
            }
        }
    }

    listen(integer chan, string nm, key av, string msg)
    {
        list s = sget(av);
        if(llGetListLength(s)==0) return;
        if(chan!=llList2Integer(s,8)) return;

        string ctx = llList2String(s,4);

        if(ctx == "menu")
        {
            if(msg == "Leash"){
                g_leashed = TRUE;
                g_leasher = av;
                llOwnerSay("[leash] "+llKey2Name(av)+" leashed you.");
                sclear(av);
                return;
            }
            if(msg == "Unleash"){
                g_leashed = FALSE;
                g_leasher = NULL_KEY;
                stop_leash_particles();
                llOwnerSay("[leash] Leash released.");
                sclear(av);
                return;
            }
            if(msg == "Set Length"){
                show_leash_length_menu(av, chan);
                return;
            }
            if(msg == "Turn"){
                g_turn_to = !g_turn_to;
                show_leash_menu(av, chan);
                return;
            }
            if(msg == "Unclip"){
                g_leashed = FALSE;
                g_leasher = NULL_KEY;
                stop_leash_particles();
                llOwnerSay("[leash] Unclipped.");
                sclear(av);
                return;
            }
            // "Follow" logic here (can toggle g_follow_mode, etc)
        }

        if(ctx == "set_length")
        {
            if(msg == "Back")   { show_leash_menu(av, chan); return; }
            if(msg == "Cancel") { sclear(av); return; }
            if(msg == "OK")     { sclear(av); return; }
            if(msg == "1" || msg == "2" || msg == "5" || msg == "10" || msg == "15" || msg == "20")
            {
                g_leash_length = (integer)msg;
                llOwnerSay("Leash length set to " + msg + " meters.");
                sclear(av);
                return;
            }
        }
    }

    timer()
    {
        timeout_check();
        if(g_leashed)
            leash_follow_logic();
        else
            stop_leash_particles();
    }
}
